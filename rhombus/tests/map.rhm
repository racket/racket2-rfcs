#lang rhombus
import:
  "version_guard.rhm"

block:
  import "static_arity.rhm"
  static_arity.check:
    Map(p, ...)
    Map.length(mp) ~method
    Map.keys(mp, [try_sort]) ~method
    Map.values(mp) ~method
    Map.get(mp, k, [default])
    Map.has_key(mp, k) ~method
    Map.copy(mp) ~method
    Map.snapshot(mp) ~method
    Map.append(mp, ...) ~method
    Map.remove(mp, k) ~method
    MutableMap.set(mp, k, val) ~method
    MutableMap.delete(mp, k) ~method
    Map.to_sequence(mp) ~method
    Map.by(==)(p, ...)
    Map.by(===)(p, ...)
    Map.by(is_now)(p, ...)
    Map.by(is_same_number_or_object)(p, ...)

check:
  {"a": 1, #'~b: 2}
  ~is Map(["a", 1], [#'~b, 2])

check:
  Map.length({"a": 1, "b": 2})
  ~is 2

check:
  Map.length({1, 2, 3})
  ~throws values("contract violation", "expected: ReadableMap")

block:
  use_static
  check:
    {"a": 1, "b": 2}.length()
    ~is 2
  check:
    {"a": 1, "b": 2}["a"] ~is 1
    {"a": 1, "b": 2}.get("a") ~is 1
    {"a": 1, "b": 2}.get("c", "other") ~is "other"
    {"a": 1, "b": 2}.get("c", fun (): "got other") ~is "got other"
  check:
    ({"a": 1, "b": 2} ++ {"a": 3})["a"] ~is 3
    ({"a": 1, "b": 2} ++ {"a": 3, "b": 4})["a"] ~is 3
    {"a": 1, "b": 2} ++ "oops" ~throws values("contract violation", "expected: Map")
    {"a": 1, "b": 2} ++ MutableMap{"a": 3} ~throws values("contract violation", "expected: Map")
    {"a": 1, "b": 2}.append()["a"] ~is 1
    {"a": 1, "b": 2}.append({"a": 2})["a"] ~is 2
    {"a": 1, "b": 2}.append({"a": 2}, {"a": 3})["a"] ~is 3
  check:
    Map{"a": 1, "b": 2}.length()
    ~is 2
  check:
    Map(["a", 1], ["b", 2]).length()
    ~is 2
  check:
    MutableMap{"a": 1, "b": 2}.length()
    ~is 2
  check:
    MutableMap(["a", 1], ["b", 2]).length()
    ~is 2
  check:
    def map = {"a": 1, "b": 2}
    map.length()
    ~is 2
  check:
    def map :: Map = dynamic({"a": 1, "b": 2})
    map.length()
    ~is 2
  check:
    def map :~ Map = dynamic({"a": 1, "b": 2})
    map.length()
    ~is 2
  check:
    def map :: Map.of(String, Int) = dynamic({"a": 1, "b": 2})
    map.length()
    ~is 2

check:
  Map.append() ~is {}
  Map.append({1: 1}) ~is {1: 1}
  Map.append({1: 1}, {1: 2}) ~is {1: 2}
  Map.append({1: 1}, {1: 2}, {1: 3}) ~is {1: 3}
  Map.append({1: 1}, {1: 2}, {1: 3}, {1: 4}) ~is {1: 4}

block:
  class Entry(key, val):
    private implements Listable
    private override to_list(): [key, val]
  check:
    Map([1, "1"], PairList[2, "2"], Array(3, "3"), Entry(4, "4"))
    ~is Map{1: "1", 2: "2", 3: "3", 4: "4"}
  check:
    MutableMap([1, "1"], PairList[2, "2"], Array(3, "3"), Entry(4, "4"))
    ~is_now MutableMap{1: "1", 2: "2", 3: "3", 4: "4"}

block:
  class Broken():
    private implements Listable
    private override to_list(): [1, "1", "oops"]
  check:
    Map([1, "1", "oops"])
    ~throws values(
      "contract violation",
      "expected: Listable.to_list && matching([_, _])",
      "[1, \"1\", \"oops\"]",
    )
  check:
    Map(PairList[1, "1", "oops"])
    ~throws values(
      "contract violation",
      "expected: Listable.to_list && matching([_, _])",
      "PairList[1, \"1\", \"oops\"]",
    )
  check:
    Map(Array(1, "1", "oops"))
    ~throws values(
      "contract violation",
      "expected: Listable.to_list && matching([_, _])",
      "Array(1, \"1\", \"oops\")",
    )
  check:
    Map(Broken())
    ~throws values(
      "contract violation",
      "expected: Listable.to_list && matching([_, _])",
      "Broken()",
    )
  check:
    MutableMap([1, "1", "oops"])
    ~throws values(
      "contract violation",
      "expected: Listable.to_list && matching([_, _])",
      "[1, \"1\", \"oops\"]",
    )
  check:
    MutableMap(PairList[1, "1", "oops"])
    ~throws values(
      "contract violation",
      "expected: Listable.to_list && matching([_, _])",
      "PairList[1, \"1\", \"oops\"]",
    )
  check:
    MutableMap(Array(1, "1", "oops"))
    ~throws values(
      "contract violation",
      "expected: Listable.to_list && matching([_, _])",
      "Array(1, \"1\", \"oops\")",
    )
  check:
    MutableMap(Broken())
    ~throws values(
      "contract violation",
      "expected: Listable.to_list && matching([_, _])",
      "Broken()",
    )

block:
  check:
    1 :: Map
    ~throws "does not satisfy annotation"
  check:
    1 :: Map.of(Any, Any)
    ~throws "does not satisfy annotation"
  check:
    1 :: Map.of(
      converting(fun (_): #false),
      converting(fun (_): #false)
    )
    ~throws "does not satisfy annotation"
  check:
    {1: 2, 2: 3, 3: 4} :: Map.of(
      converting(fun (n :: Int): n+1),
      converting(fun (n :: Int): n-1)
    )
    ~is {2: 1, 3: 2, 4: 3}

block:
  check:
    dynamic({"a": 1, "b": 2}).length() ~is 2
    dynamic({"a": 1, "b": 2})["a"] ~is 1
    dynamic({"a": 1, "b": 2}).get("a") ~is 1
    dynamic({"a": 1, "b": 2}).get("c", "other") ~is "other"
  check:
    (dynamic({"a": 1, "b": 2}) ++ {"a": 3})["a"] ~is 3
    (dynamic({"a": 1, "b": 2}) ++ {"a": 3, "b": 4})["a"] ~is 3
    dynamic({"a": 1, "b": 2}) ++ "oops" ~throws "cannot append an immutable map and other value"
    dynamic({"a": 1, "b": 2}) ++ MutableMap{"a": 3} ~throws "cannot append an immutable map and other value"
    dynamic({"a": 1, "b": 2}).append()["a"] ~is 1
    dynamic({"a": 1, "b": 2}).append({"a": 2})["a"] ~is 2
    dynamic({"a": 1, "b": 2}).append({"a": 2}, {"a": 3})["a"] ~is 3

// See also tests in "rest-args.rhm"
block:
  check:
    {"a": 1, "b": 2, & {"c": 3}}
    ~is {"a": 1, "b": 2, "c": 3}
  check:
    {"a": 1, & {"b": 2, "c": 3}}
    ~is {"a": 1, "b": 2, "c": 3}
  check:
    {& {"b": 2, "c": 3}, "a": 1}
    ~is {"a": 1, "b": 2, "c": 3}
  check:
    {& {"b": 2}, "a": 1, & {"c": 3}}
    ~is {"a": 1, "b": 2, "c": 3}
  check:
    {"c": "oops", "b": "oops", & {"b": 2}, "a": 1, & {"c": 3}}
    ~is {"a": 1, "b": 2, "c": 3}
  check:
    {"b": "oops", & {"b": 2}, "c": "oops", "a": 1, & {"c": 3}}
    ~is {"a": 1, "b": 2, "c": 3}
  check:
    {& {"b": "oops"}, "c": "oops", "b": 2, "a": 1, & {"c": 3}}
    ~is {"a": 1, "b": 2, "c": 3}
  check:
    def mutable x = []
    [{& (block: x := [1, x]; {"b": 2}), (block: x:= [2, x]; "a"): 1, & (block: x:= [3, x]; {"c": 3})},
     x]
    ~is [{"a": 1, "b": 2, "c": 3},
         [3, [2, [1, []]]]]
  check:
    {& "oops"}
    ~throws "not an immutable map"

block:
  def [x, ...] = [1, 2, 3]
  check:
    {x: x, ..., #true: 0}
    ~is {1: 1, 2: 2, 3: 3, #true: 0}
  check:
    {#true: 0, x: x, ...}
    ~is {1: 1, 2: 2, 3: 3, #true: 0}
  check:
    {#true: 0, & {7: 7}, x: x, ...}
    ~is {1: 1, 2: 2, 3: 3, 7: 7, #true: 0}
  def [[z, ...], ...] = [[1, 2, 3], [4, 5]]
  check:
    [{z: #true, ...}, ...]
    ~is [{1: #true, 2: #true, 3: #true}, {4: #true, 5: #true}]

check:
  def {"x": y} = {"x": 1}
  y
  ~is 1

check:
  def Map{"x": y} = {"x": 1}
  y
  ~is 1

check:
  def Map(["x", y]) = {"x": 1}
  y
  ~is 1

check:
  def {"x": y} = {"x": 1, "y": 2}
  y
  ~is 1

check:
  def Map{"x": y} = {"x": 1, "y": 2}
  y
  ~is 1

check:
  def ex = "x"
  def {ex +& "y": y} = {"xy": 1}
  y
  ~is 1

check:
  def {"x": x, "y": y} = {"x": 1, "y": 2}
  [x, y]
  ~is [1, 2]

check:
  def {"x": x, key: val, ...} = {"x": 1, "y": 2, "z": 3}
  [{key, ...}, {val, ...}]
  ~is [{"y", "z"}, {2, 3}]

check:
  def Map{"x": x, key: val, ...} = {"x": 1, "y": 2, "z": 3}
  [{key, ...}, {val, ...}]
  ~is [{"y", "z"}, {2, 3}]

check:
  match {}
  | Map.empty: "empty"
  | ~else: "other"
  ~is "empty"

check:
  match MutableMap{}
  | Map.empty: "empty"
  | ~else: "other"
  ~is "other"

check:
  match {1: 2}
  | Map.empty: "empty"
  | ~else: "other"
  ~is "other"

check:
  match MutableMap{1: 2}
  | Map.empty: "empty"
  | ~else: "other"
  ~is "other"

check:
  match {}
  | ReadableMap.empty: "empty"
  | ~else: "other"
  ~is "empty"

check:
  match MutableMap{}
  | ReadableMap.empty: "empty"
  | ~else: "other"
  ~is "empty"

check:
  match {1: 2}
  | ReadableMap.empty: "empty"
  | ~else: "other"
  ~is "other"

check:
  match MutableMap{1: 2}
  | ReadableMap.empty: "empty"
  | ~else: "other"
  ~is "other"

check:
  {1: "a", 2: 2, 3: 3}.keys(#true) ~is [1, 2, 3]

block:
  use_static
  check {1: "a", 2: "b"}.remove(1) ~is {2: "b"}
  check {1: "a", 2: "b"}.remove(3) ~is {1: "a", 2: "b"}
  check {1: "a", 2: "b"}.remove(1)[2] ~is "b"
  check Map.remove({1: "a", 2: "b"}, 1) ~is {2: "b"}
  check Map.remove({1: "a", 2: "b"}, 3) ~is {1: "a", 2: "b"}
  check Map.remove({1: "a", 2: "b"}, 1)[2] ~is "b"
  block:
    use_dynamic
    check dynamic({1: "a", 2: "b"}).remove(1) ~is {2: "b"}
    check dynamic({1: "a", 2: "b"}).remove(3) ~is {1: "a", 2: "b"}
    check MutableMap{1: "a", 2: "b"}.remove ~throws "no such field or method"
    check MutableMap{1: "a", 2: "b"}.remove(1) ~throws "no such field or method"

block:
  use_static
  let m = MutableMap{1: "a", 2: "b"}
  m.delete(1)
  check m ~is_now MutableMap{2: "b"}
  m.delete(3)
  check m ~is_now MutableMap{2: "b"}
  m[1] := "a"
  check m ~is_now MutableMap{1: "a", 2: "b"}
  check MutableMap.delete(m, 1) ~is #void
  check m ~is_now MutableMap{2: "b"}
  check MutableMap.delete(m, 3) ~is #void
  check m ~is_now MutableMap{2: "b"}
  m.set(1, "a")
  check m ~is_now MutableMap{1: "a", 2: "b"}
  block:
    use_dynamic
    check dynamic(m).delete(1) ~is #void
    check m ~is_now MutableMap{2: "b"}
    check dynamic(m)[1] := "a" ~is #void
    check m ~is_now MutableMap{1: "a", 2: "b"}
    check dynamic(m).delete(1) ~is #void
    check m ~is_now MutableMap{2: "b"}
    check dynamic(m).set(1, "a") ~is #void
    check m ~is_now MutableMap{1: "a", 2: "b"}

check:
  {1: "a", 2: "b"}.delete ~throws "no such field or method"
  {1: "a", 2: "b"}.delete(1) ~throws "no such field or method"

block:
  let m = MutableMap{1: "a", 2: "b"}
  let n = m.copy()
  check m is_now n ~is #true
  check m == n ~is #false
  m[2] := "a"
  n[1] := "b"
  check m ~is_now MutableMap{1: "a", 2: "a"}
  check n ~is_now MutableMap{1: "b", 2: "b"}

block:
  let m = {1: "a", 2: "b"}
  let n = m.snapshot()
  check m === n ~is #true

block:
  let m = MutableMap{1: "a", 2: "b"}
  let n = m.snapshot()
  check m == n ~is #false
  check m.snapshot() == n ~is #true
  check m.snapshot() === n ~is #false

block:
  use_static
  def mp = {1: "a", 2: "b", 3: "c"}
  check:
    for Map ((k, v): Map.to_sequence(mp)):
      values(k, v)
    ~is {1: "a", 2: "b", 3: "c"}
  check:
    for Map ((k, v): mp.to_sequence()):
      values(k, v)
    ~is {1: "a", 2: "b", 3: "c"}

block:
  use_static
  def mp = MutableMap{1: "a", 2: "b", 3: "c"}
  check:
    for Map ((k, v): Map.to_sequence(mp)):
      values(k, v)
    ~is {1: "a", 2: "b", 3: "c"}
  check:
    for Map ((k, v): mp.to_sequence()):
      values(k, v)
    ~is {1: "a", 2: "b", 3: "c"}

version_guard.at_least "8.13.0.1":
  check:
    Map.to_sequence("oops")
    ~throws values(
      "contract violation",
      "expected: ReadableMap",
      "given: \"oops\"",
    )
  check:
    ("oops" :~ Map).to_sequence()
    ~throws values(
      "contract violation",
      "expected: ReadableMap",
      "given: \"oops\"",
    )
  check:
    for Map ((k, v): Map.to_sequence("oops")):
      values(k, v)
    ~throws values(
      "contract violation",
      "expected: ReadableMap",
      "given: \"oops\"",
    )
  check:
    for Map ((k, v): ("oops" :~ Map).to_sequence()):
      values(k, v)
    ~throws values(
      "contract violation",
      "expected: ReadableMap",
      "given: \"oops\"",
    )

check:
  use_static
  class Posn(x, y)
  def map :: Map.of(List, Posn):
    {[#'foo]: Posn(1, 2), [1]: Posn(3, 4), [Box(2)]: Posn(4, 5)}
  for Set ((key, val): map):
    key.length() + val.y
  ~is {3, 5, 6}

check:
  ~eval
  use_static
  // make sure val static info isn't confused for key
  def map :: Map.of(Any, String):
    {#'foo: "foo", 1: "1", Box(2): "Box(2)"}
  for ((key, val): map):
    println(key.length() + val.length())
  ~throws "no such field or method (based on static information)"

check:
  use_static
  Map.empty.get("no such thing", #false)
  ~is #false

check:
  use_static
  def Map.empty && empty = dynamic({})
  empty.get("no such thing", #false)
  ~is #false

check:
  use_static
  Map.empty.remove("no such thing")
  ~is {}

check:
  use_static
  def Map.empty && empty = dynamic({})
  empty.remove("no such thing")
  ~is {}

check:
  use_static
  ReadableMap.empty.get("no such thing", #false)
  ~is #false

check:
  use_static
  def ReadableMap.empty && empty = dynamic({})
  empty.get("no such thing", #false)
  ~is #false

check:
  ~eval
  use_static
  ReadableMap.empty.remove("no such thing")
  ~throws "no such field or method (based on static information)"

check:
  ~eval
  use_static
  def ReadableMap.empty && empty = dynamic({})
  empty.remove("no such thing")
  ~throws "no such field or method (based on static information)"

check:
  to_string(Map{}) ~is "{}"
  to_string(Map{1: 2, 3: 4}) ~is "{1: 2, 3: 4}"
  to_string(MutableMap{}) ~is "MutableMap{}"
  to_string(MutableMap{1: 2, 3: 4}) ~is "MutableMap{1: 2, 3: 4}"

check:
  def m = MutableMap{1: 2, 3: 4}
  m[1] := m
  to_string(m)
  ~is "#0=MutableMap{1: #0#, 3: 4}"

block:
  class Posn(x, y)
  let a = Posn(1, 2)
  let b = Posn(1, 2)
  let ab = Box(1)
  let bb = Box(1)
  check a === b ~is #false
  def m1 = Map.by(===){ a: 1, b: 2 }
  def m2 = Map.by(is_same_number_or_object){ a: 1, b: 2, 1 / 2: 3, 2 / 4: 4 }
  def m3 = Map.by(is_now){ ab: 1, bb: 2 }
  check m1[a] ~is 1
  check m1[b] ~is 2
  check m2[a] ~is 1
  check m2[b] ~is 2
  check m2[1/2] ~is 4
  check m2.length() ~is 3
  check m3[ab] ~is 2
  check m3.length() ~is 1
  let str = to_string(m1)
  check (str == "Map.by(===){Posn(1, 2): 1, Posn(1, 2): 2}" || str == "Map.by(===){Posn(1, 2): 2, Posn(1, 2): 1}") ~is #true
  check to_string(m2).substring(0, 33) ~is "Map.by(is_same_number_or_object){"
  check to_string(m3).substring(0, 15) ~is "Map.by(is_now){"
  check m1 is_a Map ~is #true
  check m1 is_a Map.by(===) ~is #true
  check m1 is_a Map.by(==) ~is #false
  check {} is_a Map.by(==) ~is #true
  check m2 is_a Map.by(===) ~is #false
  check m2 is_a Map.by(is_same_number_or_object) ~is #true
  check m3 is_a Map.by(===) ~is #false
  check m3 is_a Map.by(is_now) ~is #true
  check (for Map.by(===) (i: 0..1): values(i, i+1)) ~is Map.by(===){ 0: 1 }
  check (for Map.by(is_now) (i: 0..1): values(i, i+1)) ~is Map.by(is_now){ 0: 1 }
  check (for Map.by(is_same_number_or_object) (i: 0..1): values(i, i+1)) ~is Map.by(is_same_number_or_object){ 0: 1 }
  let [x, ...] = [1, 2, 3]
  check Map.by(===){ x: x, ...} ~is Map.by(===){ 1: 1, 2: 2, 3: 3 }

  import rhombus/meta open
  expr.macro 'check_map_by $(key_comp :: Term)':
    'block:
       use_static
       check Map.by($key_comp){} ~is Map.by($key_comp){}
       check Map.by($key_comp){} ~is_a Map.by($key_comp)
       check Map.by($key_comp)([1, 2]) ~is Map.by($key_comp){ 1: 2 }
       check Map.by($key_comp){} ~is_a Map.by($key_comp).of(String, Number)
       check Map.by($key_comp){ "x" : 1 } ~is_a Map.by($key_comp).of(String, Number)
       check Map.by($key_comp){ "x" : 1 } is_a Map.by($key_comp).of(String, Number) ~is #true
       check Map.by($key_comp){ "x" : 1 } is_a Map.by($key_comp).of(Number, String) ~is #false
       check Map.by($key_comp){} ++ { 0: 1 } ~is Map.by($key_comp){ 0: 1 }
       check Map.by($key_comp){} ++ { 0: 1, 2: 3 } ~is Map.by($key_comp){ 0: 1, 2: 3 }
       check Map.by($key_comp){ x: x, $('...')} ~is Map.by($key_comp){ 1: 1, 2: 2, 3: 3 }
       check Map.by($key_comp){ x: x, $('...')}.length() ~is 3
       check [Map.by($key_comp){ x: x }, $('...')] ~is [Map.by($key_comp){ 1 : 1 },
                                                        Map.by($key_comp){ 2 : 2 },
                                                        Map.by($key_comp){ 3 : 3 }]
       check (for Map.by($key_comp) (i: 0..1): values(i, i+1)) ~is Map.by($key_comp){ 0: 1 }
       block:
         let Map.by($key_comp){ 1: v } = Map.by($key_comp){ 1: "x" }
         check v ~is "x"
       block:
         let Map.by($key_comp){ 1: v, & rest } = Map.by($key_comp){ 1: "x", 2 : 3 }
         check rest ~is_a Map.by($key_comp)
         check rest[2] ~is 3
       let m4 = MutableMap.by($key_comp){}
       m4[0] := 1
       check m4[0] ~is 1
       check m4 ~is_now MutableMap.by($key_comp){ 0: 1 }
       check m4 ~is_now MutableMap.by($key_comp)([0, 1])
       check m4 ~is_a MutableMap.by($key_comp)
       check [MutableMap.by($key_comp){ x: x }, $('...')] ~is_now [MutableMap.by($key_comp){ 1 : 1 },
                                                                   MutableMap.by($key_comp){ 2 : 2 },
                                                                   MutableMap.by($key_comp){ 3 : 3 }]'
  check_map_by ==
  check_map_by ===
  check_map_by is_now
  check_map_by is_same_number_or_object

  version_guard.at_least "8.13.0.99":
    key_comp.def 'is_anything':
      ~equals: fun (a, b, recur): #true
      ~hash_code: fun (a, recur): 1
    let m = Map.by(is_anything){ 1: 2, 3: 4 }
    check m.length() ~is 1
    check m["any value at all"] ~is 4
    check m.keys() ~is [3]

    key_comp.def 'both_42_or_both_other':
      ~equals: fun (a, b, recur): if (a == 42) | (b == 42) | (b != 42)
      ~hash_code: fun (a, recur): if (a == 42) | 42 | 1
    let m2o = Map.by(both_42_or_both_other){ 1: 2, 42: 9, 3: 4 }
    check m2o.length() ~is 2
    check m2o["any non-42 value"] ~is 4
    check m2o[42] ~is 9
    check m2o.keys().sort(math.less) ~is [3, 42]

    key_comp.def 'equals':
      ~equals: fun (a, b, recur): a == b
      ~hash_code: fun (a, recur): Equatable.hash(a)
    check_map_by equals

  #void

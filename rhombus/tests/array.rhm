#lang rhombus

check:
  Array.length(Array(1, 2, 3))
  ~is 3

check:
  Array.length([1, 2, 3])
  ~throws values("contract violation", "expected: Array")

block:
  use_static
  check:
    Array(1, 2, 3).length()
    ~is 3
  check:
    Array(1, 2, 3)[0]
    ~is 1
  check:
    Array(1, 2, 3) ++ Array(0)
    ~is_now Array(1, 2, 3, 0)
  check:
    Array(1, 2, 3).length()
    ~is 3
  check:
    def arr = Array(1, 2, 3)
    arr.length()
    ~is 3
  check:
    def arr :: Array = dynamic(Array(1, 2, 3))
    arr.length()
    ~is 3
  check:
    def arr :: Array.of_length(3) = dynamic(Array(1, 2, 3))
    arr.length()
    ~is 3
  check:
    def arr :: Array.later_of(Int) = dynamic(Array(1, 2, 3))
    arr.length()
    ~is 3
  check:
    def [v, ...] = dynamic([1, 2, 3])
    Array(v, ...).length()
    ~is 3
  check:
    class Posn(x, y)
    def arr :: Array.later_of(Posn) = Array(Posn(1, 2))
    arr[0].x
    ~is 1
  check:
    Array(1, 2, 3).copy() ~is_now Array(1, 2, 3)
    Array(4, 5, 6).copy() == Array(4, 5, 6) ~is #false
    (block:
       let s = Array(4, 5, 6)
       s.copy_from(0, Array(7))
       s) ~is_now Array(7, 5, 6)
    (block:
       let s = Array(4, 5, 6, 7, 8)
       s.copy_from(2, Array(0, 9, 10, 11), 1, 3)
       s) ~is_now Array(4, 5, 9, 10, 8)

block:
  check:
    dynamic(Array(1, 2, 3)).length()
    ~is 3
  check:
    dynamic(Array(1, 2, 3)) ++ Array(0)
    ~is_now Array(1, 2, 3, 0)
  check:
    dynamic(Array(1, 2, 3))[0]
    ~is 1
  check:
    dynamic(Array(1, 2, 3)).copy() ~is_now Array(1, 2, 3)
    dynamic(Array(4, 5, 6)).copy() == Array(4, 5, 6) ~is #false
    (block:
       let s = Array(4, 5, 6)
       dynamic(s).copy_from(0, Array(7))
       s) ~is_now Array(7, 5, 6)
    (block:
       let s = Array(4, 5, 6, 7, 8)
       dynamic(s).copy_from(2, Array(0, 9, 10, 11), 1, 3)
       s) ~is_now Array(4, 5, 9, 10, 8)


check:
  10 :: Array
  ~throws "does not satisfy annotation"

check:
  10 :: Array.of_length(1)
  ~throws "does not satisfy annotation"

check:
  10 :: Array.now_of(Any)
  ~throws "does not satisfy annotation"

check:
  10 :: Array.later_of(Any)
  ~throws "does not satisfy annotation"

check:
  10 :: Array.later_of(converting(fun (_): #false))
  ~throws "does not satisfy annotation"

check:
  Array(1) :: Array.of_length(1)
  ~completes

check:
  Array(1) :: Array.of_length(2)
  ~throws "does not satisfy annotation"

check:
  Array(1) :: Array.now_of(String)
  ~throws "does not satisfy annotation"

check:
  Array(1) :: Array.later_of(String)
  ~completes

check:
  def a :: Array.later_of(
    converting(fun (n :: Int):
                 println("run")
                 n+1)):
    Array(1)
  println(a[0])
  a[0] := 1
  println(a[0])
  ~prints "run\n2\nrun\nrun\n3\n"

check:
  def a :: Array.later_of(String) = Array(1)
  a[0]
  ~throws values(
    "current element does not satisfy annotation",
    "0",
    "String",
  )

check:
  def a :: Array.later_of(String) = Array(1, "ok")
  a[1]
  ~is "ok"

check:
  def a :: Array.later_of(String) = Array("apple")
  a[0]
  a[0] := #'oops
  ~throws values(
    "new element does not satisfy annotation",
    "0",
    "String",
  )

check:
  ~eval
  Array(Array("apple")) :: Array.now_of(Array.later_of(String))
  ~throws "converter annotation not supported for element"

check:
  use_static
  def a :: Array.later_of(String) = Array("apple")
  a[0] ++ "jack"
  ~is "applejack"

check:
  ~eval
  use_static
  def a :: Array.now_of(String) = Array("apple")
  a[0] ++ "jack"
  ~throws "specialization not known"

check:
  Array("a", "b", "c").copy() ~is_now Array("a", "b", "c")
  Array("a", "b", "c").copy(1)  ~is_now Array("b", "c")
  Array("a", "b", "c").copy(1, 2)  ~is_now Array("b")

  Array("a", "b", "c").take_left(2) ~is_now Array("a", "b")
  Array("a", "b", "c").take_right(2) ~is_now Array("b", "c")
  Array("a", "b", "c").drop_left(2) ~is_now Array("c")
  Array("a", "b", "c").drop_right(2) ~is_now Array("a")

  Array("a", "b", "c").set_in_copy(1, "x") ~is_now Array("a", "x", "c")

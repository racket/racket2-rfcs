#lang rhombus
import:
  "check.rhm" open
  racket/math open:
    only: sqr

use_static

// ---------------------------
// Positional Rest with &

fun prlist(& xs :: List): xs

check:
  prlist(1, 2, 3)
  [1, 2, 3]

fun
| altprlist(& xs :: List): xs

check:
  altprlist(4, 5, 6)
  [4, 5, 6]

fun
| addition(): 0
| addition(x): x
| addition(x, & y): x + addition(& y)

check:
  addition(1, 2, 3)
  6

check:
  addition(1, & [10, 20, 30])
  61

check:
  [1, 2, & [3, 4]]
  [1, 2, 3, 4]

begin:
  val [a, b, & rst] : [1, 2, 3, 4]
  check: a; 1
  check: b; 2
  check: rst; [3, 4]

check:
  {"a": 1, "b": 2, & {"c": 3, "d": 4}}
  {"a": 1, "b": 2, "c": 3, "d": 4}

check:
  Map{"a": 1, "b": 2, & {"c": 3, "d": 4}}
  {"a": 1, "b": 2, "c": 3, "d": 4}

check:
  Map(["a", 1], ["b", 2], & [["c", 3], ["d", 4]])
  {"a": 1, "b": 2, "c": 3, "d": 4}

check:
  {"a", "b", & {"c", "d"}}
  {"a", "b", "c", "d"}

check:
  Set{"a", "b", & {"c", "d"}}
  {"a", "b", "c", "d"}

check:
  Set("a", "b", & ["c", "d"])
  {"a", "b", "c", "d"}

begin:
  val {"a": a, "b": b, & rst} : {"a": 1, "b": 2, "c": 3, "d": 4}
  check: a; 1
  check: b; 2
  check: rst; {"c": 3, "d": 4}

begin:
  val Map{"a": a, "b": b, & rst} : {"a": 1, "b": 2, "c": 3, "d": 4}
  check: a; 1
  check: b; 2
  check: rst; {"c": 3, "d": 4}

// Match & rest on mutable maps produces an immutable copy
begin:
  val m : MutableMap{"a": 1, "b": 2}
  val r : match m
          | {"a": a, & rst}: rst
          | _: #false
  m["b"] := 3
  check: r; {"b": 2}

// ---------------------------
// Keyword Rest with ~&

fun krmap(~& m): m

check:
  krmap(~a: 1, ~b: 2)
  {keyword(~a): 1, keyword(~b): 2}

fun
| altkrmap(~& m): m

check:
  altkrmap(~a: 1, ~b: 2)
  {keyword(~a): 1, keyword(~b): 2}

fun kinetic_energy(~m: m, ~v: v): (1/2) * m * sqr(v)

check:
  kinetic_energy(~m: 2, ~v: 3)
  9
check:
  kinetic_energy(~& {keyword(~m): 4, keyword(~v): 5})
  50
check:
  kinetic_energy(~m: 6, ~& {keyword(~v): 7})
  147
check:
  kinetic_energy(~v: 2, ~& {keyword(~m): 1})
  2

fun
| kws_provided(): #false
| kws_provided(~& _): #true

check:
  kws_provided()
  #false
check:
  kws_provided(~a: 1, ~b: 2)
  #true

fun
| krpythag(~& {keyword(~a): a, keyword(~b): b, & Map.empty}):
    sqrt(sqr(a) + (sqr(b)))
| krpythag(~& {keyword(~a): a, keyword(~c): c, & Map.empty}):
    sqrt(sqr(c) - (sqr(a)))
| krpythag(~& {keyword(~b): b, keyword(~c): c, & Map.empty}):
    sqrt(sqr(c) - (sqr(b)))
| krpythag(~& {keyword(~a): a, keyword(~b): b, keyword(~c): c, & Map.empty}):
    sqr(a) + sqr(b) == sqr(c)

check: krpythag(~a: 3, ~b: 4); 5
check: krpythag(~c: 5, ~a: 3); 4
check: krpythag(~c: 5, ~b: 4); 3
check: krpythag(~a: 3, ~b: 4, ~c: 5); #true
check: krpythag(~a: 3, ~b: 4, ~c: 6); #false    

// TODO: add single-argument keyword support for `|` alt
// functions so that they don't have to be put through `~&`
// keyword rest like `krpythag` above
/*
fun
| pythag(~a: a, ~b: b): sqrt(sqr(a) + (sqr(b)))
| pythag(~a: a, ~c: c): sqrt(sqr(c) - (sqr(a)))
| pythag(~b: b, ~c: c): sqrt(sqr(c) - (sqr(b)))
| pythag(~a: a, ~b: b, ~c: c): sqr(a) + sqr(b) == sqr(c)
*/

// ---------------------------
// Repetition Rest with ...

def rrlist(x, ...):
  [x, ...]

check:
  rrlist(1, 2, 3)
  [1, 2, 3]

fun
| altrrlist(y, ...): [y, ...]

check:
  altrrlist(4, 5, 6)
  [4, 5, 6]

fun
| add(): 0
| add(x): x
| add(x, y, ...): x + add(y, ...)

check:
  add(1, 2, 3)
  6

val [n :: Integer, ...]: [10, 20, 30]
check:
  add(1, n, ...)
  61

check:
  add(1, List.repet([10, 20, 30]), ...)
  61

check:
  ~print
  match '(1 10) (2 3 4 10) (5 6 10)'
  | '($a ... 10) ...': [[a, ...], ...]
  [['1'], ['2', '3', '4'], ['5', '6']]

check:
  ~print
  val [s, ...]: ["a", "b", "c"]
  '(hi $s) ...'
  '(hi "a") (hi "b") (hi "c")'
  
check:
  ~print
  '(hi $(List.repet(["a", "b", "c"]))) ...'
  '(hi "a") (hi "b") (hi "c")'

class Posn(x, y)

def List(p :: Posn, ...) : [Posn(1, 2), Posn(3, 4)]
check:
  [p, ...][0].x
  1

fun posns_y1(& rst):
  def List(p :: Posn, ...) : rst
  [p, ...][1].y

check:
  posns_y1(Posn(1, 2), Posn(3, 4), Posn(5, 6))
  4

fun posns_y2(& List(p :: Posn, ...)):
  [p, ...][1].y
     
check:
  posns_y2(Posn(1, 2), Posn(3, 4), Posn(5, 6))
  4

fun posns_y(p :: Posn, ...):
  [p, ...][1].y
     
check:
  posns_y(Posn(1, 2), Posn(3, 4), Posn(5, 6))
  4

#lang rhombus

// check for sensible precedence of `::` mixed with expression
check:
  "a" :: String && #true ~is #true
  "a" :: String +& "ok" ~is "aok"

check:
  ~eval
  "a" :: PosInt . count()
  ~throws "operator precedence"

check:
  1 is_a Function ~is #false
  1 is_a Function.of_arity(1) ~is #false
  List is_a Function ~is #true
  List is_a Function.of_arity(1) ~is #true
  List is_a Function.of_arity(1, 2, 3) ~is #true
  Pair is_a Function.of_arity(2) ~is #true
  Pair is_a Function.of_arity(1, 2) ~is #false
  (fun (x): #void) is_a Function.of_arity(1) ~is #true
  (fun (x, ~y = 0): #void) is_a Function.of_arity(1) ~is #true
  (fun (x, ~y): #void) is_a Function.of_arity(1) ~is #false
  (fun (x, ~y = 0): #void) is_a Function.of_arity(1, ~y) ~is #true
  (fun (x, ~y): #void) is_a Function.of_arity(1, ~y) ~is #true

check:
  0 :: converting(fun (i :: Int when i mod 3 == 0): i)
  1 :: converting(fun (i :: Int unless i mod 3 == 0): i)
  [1, 2, 3] :: converting(fun ([x, ...] when math.sum(x, ...) == 6): #true)
  ~completes

check:
  0 is_a converting(fun (i :: Int when i mod 3 == 0): i)
  1 is_a converting(fun (i :: Int unless i mod 3 == 0): i)
  [1, 2, 3] is_a converting(fun ([x, ...] when math.sum(x, ...) == 6): #true)
  ~completes

block:
  fun is_multiple_of(n):
    fun (v):
      v is_a Int && v mod n == 0
  check:
    0 ~is_a satisfying(is_multiple_of(1))
    1 ~is_a satisfying(is_multiple_of(1))
    15 ~is_a satisfying(is_multiple_of(3)) && satisfying(is_multiple_of(5))

check:
  #false is_a satisfying("not a function")
  ~throws values("contract violation", "expected: Function.of_arity(1)")

check:
  #false is_a satisfying(fun (): #false)
  ~throws values("contract violation", "expected: Function.of_arity(1)")
